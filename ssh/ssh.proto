//
// Copyright 2021 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto3";

package gnsi.ssh;

import "github.com/openconfig/gnoi/types/types.proto";

// This package is a work in progress. It may change in the future. :-)
option go_package = "github.com/openconfig/gnsi/ssh";
option (gnoi.types.gnoi_version) = "0.1.0";

// The SSH Credentials Management Service exported by targets.
//
// This service exports two RPCs, MutateAccountCredentials() and
// MutateHostCredentials(), which are used to manage the account-related SSH
// credentials, and the host-related SSH credentials on a target respectively.
//
// Note that for the sake of data consistency and API simplicity, only one RPC
// may be in progress at a time. An attempt to initiate any of the RPCs while
// another one is already in progress will be rejected with an error.
// For example, when the MutateAccountCredentials() RPC is in progress another
// call to the MutateAccountCredentials() or the MutateHostCredentials() RPC
// will be rejected.

service Ssh {
  // MutateAccountCredentials allows to specify an authentication SSH service
  // policy to the network element. The policy, if valid, replaces the existing
  // policy.
  //
  // Canonical error codes are to be used as responses. See
  // https://grpc.io/docs/guides/error/ for more details.
  //
  // Sets the SSH authorized keys list in whole for a system account
  // (e.g. the set of SSH keys accepted for login to the account).
  // Also sets the SSH authorized users list in whole for a system account
  // (e.g. the set of SSH certificate users accepted for login to the account).
  //
  // Case 1: Both the credentials and authorized usernames are set.
  //
  //   Step 1: Start the stream
  //     Client <---- MutateAccountCredentials() RPC stream begin ------> Target
  //
  //   Step 2: New credentials are installed
  //     Client -----> MutateAuthorizedKeysRequest----> Target
  //     Client <----- MutateAuthorizedKeysResponse <--- Target
  //
  //   Step 3: New authorized user names are installed
  //     Client -----> MutateAuthorizedUsersRequest----> Target
  //     Client <----- MutateAuthorizedUsersResponse <--- Target
  //
  //   Step 4 (optional): Test/Validation by the client.
  //     During this step client attempts to create a new connection to
  //     the target using the new certificates/keys and validates that
  //     the certificates/keys "work".
  //     Once verfied, the client then proceeds to finalize the rotation.
  //     If the new connection cannot be completed the client will cancel the
  //     RPC thereby forcing the target to rollback all the certificates/keys.
  //
  //   Step 5: Final commit.
  //     Client -----> FinalizeRequest----> Target
  //
  //
  // Case 2: Only the credentials are set.
  //
  //   Step 1: Start the stream
  //     Client <---- MutateAccountCredentials() RPC stream begin ------> Target
  //
  //   Step 2: New credentials are installed
  //     Client -----> MutateAuthorizedKeysRequest----> Target
  //     Client <----- MutateAuthorizedKeysResponse <--- Target
  //
  //   Step 3 (optional): Test/Validation by the client.
  //     During this step client attempts to create a new connection to
  //     the target using the new certificates/keys and validates that
  //     the certificates/keys "work".
  //     Once verfied, the client then proceeds to finalize the rotation.
  //     If the new connection cannot be completed the client will cancel the
  //     RPC thereby forcing the target to rollback all the certificates/keys.
  //
  //   Step 4: Final commit.
  //     Client -----> FinalizeRequest----> Target
  //
  //
  // Case 3: Only authorized usernames are set.
  //
  //   Step 1: Start the stream
  //     Client <---- MutateAccountCredentials() RPC stream begin ------> Target
  //
  //   Step 2: New authorized user names are installed
  //     Client -----> MutateAuthorizedUsersRequest----> Target
  //     Client <----- MutateAuthorizedUsersResponse <--- Target
  //
  //   Step 3 (optional): Test/Validation by the client.
  //     During this step client attempts to create a new connection to
  //     the target using the new certificates/keys and validates that
  //     the certificates/keys "work".
  //     Once verfied, the client then proceeds to finalize the rotation.
  //     If the new connection cannot be completed the client will cancel the
  //     RPC thereby forcing the target to rollback all the certificates/keys.
  //
  //   Step 4: Final commit.
  //     Client -----> FinalizeRequest----> Target
  //
  //
  rpc MutateAccountCredentials(stream MutateAccountCredentialsRequest)
      returns (stream MutateAccountCredentialsResponse);

  // MutateHostCredentials() allows for changing the Cetificate Authority
  // public key. This key is used to verify certificates presented by the client
  // to the SSH server during connection establisment.
  //
  // Use Case:
  //
  //   Step 1: Start the stream
  //     Client <---- MutateHostCredentials() RPC stream begin ------> Target
  //
  //   Step 2: Set CA public key
  //     Client -----> MutateCaPublicKeyRequest----> Target
  //     Client <----- MutateCaPublicKeyResponse <--- Target
  //
  //   Step 3 (optional): Test/Validation by the client.
  //     During this step client attempts to create a new connection to
  //     the target using the new certificates/keys and validates that
  //     the certificates/keys "work".
  //     Once verfied, the client then proceeds to finalize the rotation.
  //     If the new connection cannot be completed the client will cancel the
  //     RPC thereby forcing the target to rollback all the certificates/keys.
  //
  //   Step 4: Final commit.
  //     Client -----> FinalizeRequest----> Target
  //
  rpc MutateHostCredentials(stream MutateHostCredentialsRequest)
      returns (stream MutateHostCredentialsResponse) {}
}

//
// Messages relared to MutateAccountCredentials RPC.
//

message MutateAccountCredentialsRequest {
  oneof request {
    MutateAuthorizedKeysRequest credential = 1;
    MutateAuthorizedUsersRequest user = 2;
    FinalizeRequest finalize = 3;
  }
}

// MutateAccountCredentialsResponse is the response to
// the MutateAccountCredentials RPC.
message MutateAccountCredentialsResponse {
  oneof response {
    MutateAuthorizedKeysResponse credential = 1;
    MutateAuthorizedUsersResponse user = 2;
  }
}

message MutateAuthorizedKeysRequest {
  // A list of credentials that are to be accepted on the SSH service on
  // the network element.
  // Multiple credentials MAY be specified to allow for multiple
  // system roles, or specific user restrictions to be described.
  repeated AccountCredentials credentials = 1;
}

message Option {
  // An option that is specified for a authorized user or key entry.
  // For example, for OpenSSH, an entry can have an option
  // `from="*.sales.example.net,!pc.sales.example.net"`
  // For such option the `name` would be `from` while the `value`
  // would be `*.sales.example.net,!pc.sales.example.net`.
  //
  // If a specified option is unknown then the whole request should be rejected.
  string name = 1;
  string value = 2;
}

message AccountCredentials {
  message AuthorizedKey {
    bytes authorized_key = 1;
    // Options specified for this authorized key.
    repeated Option options = 2;
  }

  // The system role account name (e.g. root). This account must exist.
  string account = 1;
  // `authorized_keys` specifies one or more SSH keys that is permitted for the
  // system role.
  repeated AuthorizedKey authorized_keys = 2;
  // `version` contains versioning information that is controlled by
  // the credential manager and reported as-is by the telemetry reporting system
  // (ie, transparent to the device credential service).  Credential managers
  // should choose version strings as discrete as possible to ease alert
  // generation (eg, for credentials sourced from a bundle, the timestamp of
  // the bundle should be used but not the time when the credential is pushed to
  // a particular switch).  Also, such version strings should be persisted by
  // the devices onto non-volatile memory for preservation across system
  // reboots.
  string version = 3;
  // `created_on` contains information when the credentials were created.
  // This information is controlled by the credential manager and reported as-is
  // by the telemetry reporting system (ie, transparent to the device credential
  // service).  Credential managers should use the timestamp of the moment when
  // credential was created, not the time when the credential is pushed to
  // a particular switch).
  // Also, this timestamp should be persisted by the devices onto non-volatile
  // memory for preservation across system reboots.
  // `created_on` is a timestamp: the number of seconds since
  // January 1st, 1970 00:00:00 GMT.
  uint64 created_on = 4;
}

message MutateAuthorizedKeysResponse {}

message MutateAuthorizedUsersRequest {
  // A list of policies that are to be applied on the SSH service on
  // the network element.
  // Multiple policies MAY be specified to allow for multiple
  // system roles, or specific user restrictions to be described.
  repeated UserPolicy policies = 1;
}

message UserPolicy {
  message SshAuthorizedUser {
    string authorized_user = 1;
    // Options specified for this authorized user.
    repeated Option options = 2;
  }

  // The system role account name (e.g. root). This account must exist.
  string account = 1;

  // List of authorized usernames for this system role as found in the SSH
  // certificate.
  repeated SshAuthorizedUser authorized_users = 2;
  // `version` contains versioning information that is controlled by
  // the credential manager and reported as-is by the telemetry reporting system
  // (ie, transparent to the device credential service).  Credential managers
  // should choose version strings as discrete as possible to ease alert
  // generation (eg, for credentials sourced from a bundle, the timestamp of
  // the bundle should be used but not the time when the credential is pushed to
  // a particular switch).  Also, such version strings should be persisted by
  // the devices onto non-volatile memory for preservation across system
  // reboots.
  string version = 3;
  // `created_on` contains information when the credentials were created.
  // This information is controlled by the credential manager and reported as-is
  // by the telemetry reporting system (ie, transparent to the device credential
  // service).  Credential managers should use the timestamp of the moment when
  // credential was created, not the time when the credential is pushed to
  // a particular switch).
  // Also, this timestamp should be persisted by the devices onto non-volatile
  // memory for preservation across system reboots.
  // `created_on` is a timestamp: the number of seconds since
  // January 1st, 1970 00:00:00 GMT.
  uint64 created_on = 4;
}

message MutateAuthorizedUsersResponse {}

//
// Messages relared to MutateHostCredentials RPC.
//

message MutateHostCredentialsRequest {
  oneof request {
    MutateCaPublicKeyRequest set_ca_public_key = 1;
    FinalizeRequest finalize = 2;
  }
}

message MutateHostCredentialsResponse {
  oneof response {
    MutateCaPublicKeyResponse set_ca_public_key = 1;
  }
}

message MutateCaPublicKeyRequest {
  // Certificate Authority public keys to be used to verify certificates
  // presented by clients during connection establishment.
  // SSH-formatted.
  repeated bytes ssh_ca_public_keys = 1;
  // `version` contains versioning information that is controlled by
  // the credential manager and reported as-is by the telemetry reporting system
  // (ie, transparent to the device credential service).  Credential managers
  // should choose version strings as discrete as possible to ease alert
  // generation (eg, for credentials sourced from a bundle, the timestamp of
  // the bundle should be used but not the time when the credential is pushed to
  // a particular switch).  Also, such version strings should be persisted by
  // the devices onto non-volatile memory for preservation across system
  // reboots.
  string version = 2;
  // `created_on` contains information when the credentials were created.
  // This information is controlled by the credential manager and reported as-is
  // by the telemetry reporting system (ie, transparent to the device credential
  // service).  Credential managers should use the timestamp of the moment when
  // credential was created, not the time when the credential is pushed to
  // a particular switch).
  // Also, this timestamp should be persisted by the devices onto non-volatile
  // memory for preservation across system reboots.
  // `created_on` is a timestamp: the number of seconds since
  // January 1st, 1970 00:00:00 GMT.
  uint64 created_on = 3;
}

message MutateCaPublicKeyResponse {}

message FinalizeRequest {}
