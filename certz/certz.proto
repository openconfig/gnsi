//
// Copyright 2022 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// This file defines the gNSI API to be used for certificate rotation.
syntax = "proto3";

package gnsi.certz.v1;

import "github.com/openconfig/gnsi/version/version.proto";
import "google/protobuf/any.proto";

option go_package = "github.com/openconfig/gnsi/cert";

// The Certificate Management Service exported by targets.
//
// This service exports multiple RPCs. Three of them are used to manage SSL
// profiles, one to check if the target has the capability to create a CSR and
// one, Rotate(), which is used to rotate (i.e. update or replace) an existing
// certificate, an existing trust bundle and/or an existing certificate
// revocation list bundle that are part of a SSL profile on a target.
//
// Note that for the sake of data consistency and API simplicity, only one RPC
// may be in progress at a time. An attempt to initiate another RPC while
// one is already in progress will be rejected with an error.
//
// The service makes an assumption that the credentials it manages are
// organized in the following _logical_ topology.
//
// Target (as seen from gNSI.certificate microservice point of view)
// |
// +-+ SSL profile for gNXI; always present; ssl_profile_id := "gNxI"
// | |
// | +-+ certificate
// | | +- certificate (with public key)
// | | +- private key
// | |
// | +-+ trust bundle (Certificate Authority certificates)
// | | +- CA Root certificate
// | | +- CA Intermediate Certificate
// | |
// | +-+ Certificate Revocation List bundle
// | | +-+ Certificate Revocation List A
// | | +-+ Certificate Revocation List B
// | |
// | +- authentication policy
// |
// +-+ Another SSL profile used by another service
//   |
//   +-+ certificate
//   | +- certificate (with public key)
//   | +- private key
//   |
//   +-+ trust bundle (Certificate Authority certificates)
//   | +- CA Root certificate
//   | +- CA Intermediate Certificate
//   |
//   +-+ Certificate Revocation List bundle
//   | +-+ Certificate Revocation List A
//   | +-+ Certificate Revocation List B
//   |
//   +- authentication policy
//
// As shown above the gNSI.certz manages certificates (public and private keys),
// trust bundles (Certificate Authority chain of certificates) and Certificate
// Revocation List (CRL) bundles grouped into SSL profiles.
// Each profile has a unique ID and consists of exactly one certificate, one
// CA trust bundle and one CRL bundle.
// There is at least one SSL profile present on the target, the one that is used
// by all gNxI microservices. It is created during the bootstrap phase and
// cannot be removed.
// Other services that require credentials _can_ use the same SSL profile as
// the gNxI server or they can use a SSL profiles that is created using
// the `AddProfile()` RPC. In any case, the assignment of a SSL profile to
// a service is done by modifying the `/oc-sys:system/
//  oc-sys-grpc:grpc-servers/oc-sys-grpc:grpc-server/oc-sys-grpc:config/
//  oc-sys-grpc:certificate-id` OpenConfig leaf.
//
// Note that this architecture implies that every operation performed
// on a credential that is part of a SSL profile specified in the request
// changes the credential at the same time for all services configured to use
// this particular SSL profile.

service Certz {
  // Rotate will replace an existing device certificate and/or CA certificates
  // (trust bundle) or/and a certificate revocation list bundle on the target.
  // The new device certificate can be created from a target-generated or
  // client-generated CSR. In the latter case the client has to provide
  // corresponding private key with the signed certificate.
  // If the stream is broken or any of the steps fail the target must rollback
  // to the original state, i.e. revert any changes to the certificate,
  // CA certificates and the Certificate Revocation List bundle.
  //
  // The following describes a number of use cases each presenting the expected
  // sequence of message exchange.
  //
  // Case 1: Client generates the CSR, gets it signed and then uploads it.
  //
  //   Step 1: Start the stream
  //     Client <---- Rotate() RPC stream begin ------> Target
  //
  //   Step 2: CSR Generation and certificate signing
  //     Client generates the CSR and gets the certificate signed by the CA.
  //
  //   Step 3: Send Certificate and optional content to the Target.
  //     mandatory: signed certificate with private key
  //     optional: trust bundle - Certificate Authority certificate chain
  //     optional: certificate revocation list bundle
  //     optional: authentication policy
  //     Client --> UploadRequest(certificate, [trust_bundle],
  //                              [certificate_revocation_list],
  //                              [authentication_policy]) ----> Target
  //     Client <-- UploadResponse <--- Target
  //
  //   Step 4 (optional): Test/Validation by the client.
  //     During this step client attempts to create a new connection to
  //     the target using the new certificates and validates that
  //     the certificates "work".
  //     If the new connection cannot be completed the client will cancel the
  //     RPC thereby forcing the target to rollback all the certificates.
  //     If new certificate revocation list bundle has been uploaded in step 3,
  //     during this step the client also attempts to establish a new connection
  //     to the target using revoked certificate(s) - the attempt must fail
  //     proving that the certificates have been revoked.
  //     Once verified, the client then proceeds to finalize the rotation.
  //
  //   Step 5: Final commit.
  //     Client ---> FinalizeRequest ----> Target
  //
  // Case 2: Target generates the CSR, client gets it signed and uploads it.
  //
  //   Step 1: Start the stream
  //     Client <---- Rotate() RPC stream begin ------> Target
  //
  //   Step 2: CSR
  //     Client -----> GenerateCSRRequest----> Target
  //     Client <----- GenerateCSRResponse <--- Target
  //
  //   Step 3: Certificate Signing
  //     Client gets the certificate signed by the CA.
  //
  //   Step 4: Send Certificate and optional content to the Target.
  //     mandatory: signed certificate without private key
  //     optional: trust bundle - Certificate Authority certificate chain
  //     optional: certificate revocation list bundle
  //     optional: authentication policy
  //     Client --> UploadRequest(certificate, [trust_bundle],
  //                              [certificate_revocation_list],
  //                              [authentication_policy]) ----> Target
  //     Client <-- UploadResponse <--- Target
  //
  //   Step 5: Test/Validation by the client.
  //     During this step client attempts to create a new connection to
  //     the target using the new certificates and validates that
  //     the certificates "work".
  //     If the new connection cannot be completed the client will cancel the
  //     RPC thereby forcing the target to rollback all the certificates.
  //     If new certificate revocation list bundle has been uploaded in step 4,
  //     during this step the client also attempts to establish a new connection
  //     to the target using revoked certificate(s) - the attempt must fail
  //     proving that the certificates have been revoked.
  //     Once verified, the client then proceeds to finalize the rotation.
  //
  //   Step 6: Final commit.
  //     Client ---> FinalizeRequest ----> Target
  //
  // Case 3: Client changes only trust bundle on the Target.
  //
  //   Step 1: Start the stream
  //     Client <---- Rotate() RPC stream begin ------> Target
  //
  //   Step 2: Send CA Certificate Bundle to the Target.
  //     mandatory: trust bundle - Certificate Authority chain
  //     Client --> UploadRequest(trust_bundle) ----> Target
  //     Client <-- UploadResponse <--- Target
  //
  //   Step 3 (optional): Test/Validation by the client.
  //     During this step client attempts to create a new connection to
  //     the target using a new certificate that can be validated using the new
  //     trust bundle and validates that the CA certificates "work".
  //     If the new connection cannot be completed the client will cancel the
  //     RPC thereby forcing the target to rollback all the certificates.
  //     If new certificate revocation list bundle has been uploaded in step 2,
  //     during this step the client also attempts to establish a new connection
  //     to the target using revoked certificate(s) - the attempt must fail
  //     proving that the certificates have been revoked.
  //     Once verified, the client then proceeds to finalize the rotation.
  //
  //   Step 4: Final commit.
  //     Client ---> FinalizeRequest ----> Target
  //
  // Case 4: Client provides certificate revocation list bundle to the Target.
  //
  //   Step 1: Start the stream
  //     Client <---- Rotate() RPC stream begin ------> Target
  //
  //   Step 2: Send certificate revocation list bundle to the target.
  //     mandatory: certificate revocation list bundle
  //     Client --> UploadRequest(certificate_revocation_list) ----> Target
  //     Client <-- UploadResponse <--- Target
  //
  //   Step 3 (optional): Test/Validation by the client.
  //     During this step the client attempts to establish a new connection
  //     to the target using revoked certificate(s) - the attempt must fail
  //     proving that the certificates have been revoked.
  //     If the new connection can be completed the client will cancel the
  //     RPC thereby forcing the target to rollback all the certificates.
  //     Once verified, the client then proceeds to finalize the rotation.
  //
  //   Step 4: Final commit.
  //     Client ---> FinalizeRequest ----> Target
  //
  // Case 5: Client provides authentication policy to the Target.
  //
  //   Step 1: Start the stream
  //     Client <---- Rotate() RPC stream begin ------> Target
  //
  //   Step 2: Send authentication policy to the target.
  //     mandatory: authentication policy
  //     Client --> UploadRequest(authentication_policy) ----> Target
  //     Client <-- UploadResponse <--- Target
  //
  //   Step 3 (optional): Test/Validation by the client.
  //     During this step the client attempts to establish a new connection
  //     to the target using certificate(s) signed with incorrect CA -
  //     the attempt must fail proving that the authentication policy works.
  //     If the new connection can be completed the client will cancel the
  //     RPC thereby forcing the target to rollback the authentication policy.
  //     Once verified, the client then proceeds to finalize the rotation.
  //
  //   Step 4: Final commit.
  //     Client ---> FinalizeRequest ----> Target
  //
  rpc Rotate(stream RotateCertificateRequest)
      returns (stream RotateCertificateResponse);

  // AddProfile is part of SSL profile management and allows for adding new
  // SSL profile.
  // When a SSL profile is added all its elements, i.e. certificate, CA trust
  // bundle and a set of certificate revocation lists are created and they are
  // empty, so before they can be used they have to be 'rotated' using
  // the `Rotate()` RPC.
  // Note that an attempt to add an already existing profile will be rejected
  // with an error.
  rpc AddProfile(AddProfileRequest) returns (AddProfileResponse);

  // DeleteProfile is part of SSL profile management and allows for removing
  // an existing SSL profile.
  // Note that an attempt to remove a not existing profile will result
  // in an error.
  // Not also that the profile used by the gNxI server cannot be deleted and an
  // attempt to remove it will rejected with an error.
  rpc DeleteProfile(DeleteProfileRequest)
      returns (DeleteProfileResponse);

  // GetProfileList is part of SSL profile management and allows for
  // retrieving a list of IDs of SSL profiles present on the target.
  rpc GetProfileList(GetProfileListRequest)
      returns (GetProfileListResponse);

  // An RPC to ask a target if it can generate a Certificate Signing Request.
  rpc CanGenerateCSR(CanGenerateCSRRequest) returns (CanGenerateCSRResponse);
}

// Request messages to rotate existing certificates on the target.
message RotateCertificateRequest {
  // If set to `true` the requested operation will succeed even if the
  // `version` is already in use (is not unique).
  // If set to `false` the requested operation will fail and the streaming RPC
  // will be closed with the `AlreadyExists` error if the `version` is already
  // in use (is not unique).
  // It is a no-op for the `finalize_rotation` request.
  bool force_overwrite = 1;

  // An identifier for the specific SSL profile (collection of
  // certs/bundles/CRLs) which is being rotated through this stream.
  // Leaving this field blank means that this stream will rotate the SSL profile
  // which is currently being used by the gNSI service.
  string ssl_profile_id = 2;

  // Request Messages.
  oneof rotate_request {
    GenerateCSRRequest generate_csr = 3;
    UploadRequest certificates = 4;
    FinalizeRequest finalize_rotation = 5;
  }
}

// Response Messages from the target.
message RotateCertificateResponse {
  // Response messages.
  oneof rotate_response {
    GenerateCSRResponse generated_csr = 1;
    UploadResponse certificates = 2;
  }
}

// A Finalize message is sent to the target to confirm the Rotation of
// the certificate and that the certificate should not be rolled back when
// the RPC concludes. The certificate must be rolled back if the target returns
// an error after receiving a Finalize message.
message FinalizeRequest {
}

// A request to add a new SSL profile.
message AddProfileRequest {
  // The ID of the SSL profile to be created.
  string ssl_profile_id = 1;
}

// A response to a request to add a new SSL profile.
message AddProfileResponse {
}

// A request to remove an existing SSL profile.
message DeleteProfileRequest {
  // The ID of the SSL profile to be removed.
  string ssl_profile_id = 1;
}

// A response to a request to remove an existing SSL profile.
message DeleteProfileResponse {
}

// A request for a list of all SSL profiles present on the target.
message GetProfileListRequest {
}

// A response with the list of all SSL profiles present on the target.
message GetProfileListResponse {
  // A list of IDs of SSL profiles that exist on the target.
  repeated string ssl_profile_ids = 1;
}

// CSRSuite specifies the valid types of keys and digests that can be used
// to generate CSRs
enum CSRSuite {
  CSRSUITE_CIPHER_UNSPECIFIED = 0;

  // format:
  // <certificate type>_<key type>_<signature algorithm>
  CSRSUITE_X509_KEY_TYPE_RSA_2048_SIGNATURE_ALGORITHM_SHA_2_256 = 1;
  CSRSUITE_X509_KEY_TYPE_RSA_2048_SIGNATURE_ALGORITHM_SHA_2_384 = 2;
  CSRSUITE_X509_KEY_TYPE_RSA_2048_SIGNATURE_ALGORITHM_SHA_2_512 = 3;

  CSRSUITE_X509_KEY_TYPE_RSA_3072_SIGNATURE_ALGORITHM_SHA_2_256 = 4;
  CSRSUITE_X509_KEY_TYPE_RSA_3072_SIGNATURE_ALGORITHM_SHA_2_384 = 5;
  CSRSUITE_X509_KEY_TYPE_RSA_3072_SIGNATURE_ALGORITHM_SHA_2_512 = 6;

  CSRSUITE_X509_KEY_TYPE_RSA_4096_SIGNATURE_ALGORITHM_SHA_2_256 = 7;
  CSRSUITE_X509_KEY_TYPE_RSA_4096_SIGNATURE_ALGORITHM_SHA_2_384 = 8;
  CSRSUITE_X509_KEY_TYPE_RSA_4096_SIGNATURE_ALGORITHM_SHA_2_512 = 9;

  CSRSUITE_X509_KEY_TYPE_ECDSA_PRIME256V1_SIGNATURE_ALGORITHM_SHA_2_256 = 10;
  CSRSUITE_X509_KEY_TYPE_ECDSA_PRIME256V1_SIGNATURE_ALGORITHM_SHA_2_384 = 11;
  CSRSUITE_X509_KEY_TYPE_ECDSA_PRIME256V1_SIGNATURE_ALGORITHM_SHA_2_512 = 12;

  CSRSUITE_X509_KEY_TYPE_ECDSA_SECP384R1_SIGNATURE_ALGORITHM_SHA_2_256 = 13;
  CSRSUITE_X509_KEY_TYPE_ECDSA_SECP384R1_SIGNATURE_ALGORITHM_SHA_2_384 = 14;
  CSRSUITE_X509_KEY_TYPE_ECDSA_SECP384R1_SIGNATURE_ALGORITHM_SHA_2_512 = 15;

  CSRSUITE_X509_KEY_TYPE_ECDSA_SECP521R1_SIGNATURE_ALGORITHM_SHA_2_256 = 16;
  CSRSUITE_X509_KEY_TYPE_ECDSA_SECP521R1_SIGNATURE_ALGORITHM_SHA_2_384 = 17;
  CSRSUITE_X509_KEY_TYPE_ECDSA_SECP521R1_SIGNATURE_ALGORITHM_SHA_2_512 = 18;

  CSRSUITE_X509_KEY_TYPE_EDDSA_ED25519 = 19;
}

// A message type specifying the Subject Alternative Name for
// use as an x509 certificate extension
message V3ExtensionSAN {
  repeated string dns = 1;     // DNS names for use in SAN
  repeated string emails = 2;  // Email addresses for use in SAN
  repeated string ips = 3;     // IP addresses for use in SAN
  // protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
  repeated string uris = 4;    // URIs for use in SAN
}

// A set of parameters a Certificate Signing Request.
// Used to specify what type of CSR the client expects from the target.
message CSRParams {
  CSRSuite csr_suite = 1;

  // Required field for any type of certificate
  string common_name = 2;           // e.g "device.corp.google.com"

  // Optional fields for any type of certificate
  string country = 3;               // e.g "US"
  string state = 4;                 // e.g "CA"
  string city = 5;                  // e.g "Mountain View"
  string organization = 6;          // e.g "Google"
  string organizational_unit = 7;   // e.g "Security"
  string ip_address = 8;
  string email_id = 9;
  V3ExtensionSAN san = 10;          // Subject Alternative Name
}

// A request to ask the target if it can generate key pairs.
message CanGenerateCSRRequest {
  CSRParams params = 1;
}

// Response from the target about whether it can generate a CSR with the given
// parameters.
message CanGenerateCSRResponse {
  bool can_generate = 4;
}

// Types of certificates.
enum CertificateType {
  // 1 - 500 for public use.
  // 501 onwards for private use.
  CERTIFICATE_TYPE_UNSPECIFIED = 0;
  CERTIFICATE_TYPE_X509 = 1;
}

enum CertificateEncoding {
  // 1 - 500 for public use.
  // 501 onwards for private use.
  CERTIFICATE_ENCODING_UNSPECIFIED = 0;
  CERTIFICATE_ENCODING_PEM = 1;
  CERTIFICATE_ENCODING_DER = 2;
  CERTIFICATE_ENCODING_CRT = 3;
}

message CertificateChain {
  Certificate certificate = 1;
  // parent is the certificate which was used to sign the current certificate.
  // It is nil in the case of the root cert.
  CertificateChain parent = 2;
}

// A certificate.
message Certificate {
  // Type of certificate.
  CertificateType type = 1;
  // Certificate encoding type.
  CertificateEncoding encoding = 2;

  // Actual certificate.
  // The exact encoding depends upon the type of certificate.
  // for X509, this should be a PEM encoded Certificate.
  bytes certificate = 3;

  // Optional.
  // Not needed if the device knows the private key or does not have to know it.
  bytes private_key = 4;
}

// A certificate revocation list (CRL)
message CertificateRevocationList {
  // Type of the CRL.
  CertificateType type = 1;
  // CRL encoding type.
  CertificateEncoding encoding = 2;

  // Actual CRL.
  // The exact encoding depends upon the type of CRL.
  // for X509, this should be a PEM encoded CRL.
  bytes certificate_revocation_list = 3;

  // ID of this CRL, which is the CRL file hash.
  string id = 4;
}

message CertificateRevocationListBundle {
  repeated CertificateRevocationList certificate_revocation_lists = 1;
}

// An authentication policy.
// This policy defines which Certificate Authority can sign which certificate.
message AuthenticationPolicy {
  // Actual authentication policy.
  oneof policy {
    google.protobuf.Any serialized = 1;
  }
}

// An entity.
message Entity {
  // `version` contains versioning information that is controlled by
  // the credential manager and reported as-is by the telemetry reporting system
  // (ie, transparent to the device credential service).  Credential managers
  // should choose version strings as discrete as possible to ease alert
  // generation.
  // Also, this version string must be persisted by the device for preservation
  // across system reboots / cold-starts.
  string version = 1;
  // `created_on` contains information when the credentials were created.
  // This information is controlled by the credential manager and reported as-is
  // by the telemetry reporting system (ie, transparent to the device credential
  // service).  Credential managers should use the timestamp of the moment when
  // credential was created, not the time when the credential is pushed to
  // a particular device).
  // Also, this timestamp must be persisted by the device for preservation
  // across system reboots / cold-starts.
  // `created_on` is a timestamp: the number of seconds since
  // January 1st, 1970 00:00:00 GMT, a.k.a. unix epoch.
  uint64 created_on = 2;

  oneof entity {
    CertificateChain certificate_chain = 3;
    CertificateChain trust_bundle = 4;
    CertificateRevocationListBundle certificate_revocation_list_bundle = 5;
    AuthenticationPolicy authentication_policy = 6;
  }
}

// UploadRequest instructs the target to store the given entities (certificate,
// and/or trust bundle and certificate revocation list bundle).
//
// As the target does not generate the CSR, the public/private key pair is
// generated externally and the target is provided with the private/public key
// pair.
//
// The trust bundle (a chain of Certificate Authority certificates) can be
// used to validate client's certificates.
// To improve performance in the Target, certificates can be ordered.
// Groups of chained certificates should be last, where within, the root
// certificate is the last one. E.g.:
// CertA, CertB, CertB-Root, CertC, CertC-Intermediate, CertC-Root
message UploadRequest {
  repeated Entity entities = 1;
}

message UploadResponse {
}

// A certificate signing request (CSR)
message CertificateSigningRequest {
  // Type of the CSR.
  CertificateType type = 1;
  // CSR encoding type.
  CertificateEncoding encoding = 2;

  // Actual CSR.
  // The exact encoding depends upon the type of CSR.
  // for X509, this should be a PEM encoded CSR.
  bytes certificate_signing_request = 3;
}

// A message sent by a client requesting the target to generate a CSR with
// the specified parameters.
message GenerateCSRRequest {
  CSRParams params = 1;
}
// A message sent by the target as response to the GenerateCSRRequest.
message GenerateCSRResponse {
  CertificateSigningRequest certificate_signing_request = 1;
}
